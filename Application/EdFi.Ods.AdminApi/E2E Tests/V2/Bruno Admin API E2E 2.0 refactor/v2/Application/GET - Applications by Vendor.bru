meta {
  name: Applications by Vendor
  type: http
  seq: 13
}

get {
  url: {{API_URL}}/v2/vendors/{{ApplicationVendorId}}/applications
  body: none
  auth: inherit
}

script:pre-request {
  console.log("ðŸ”§ Setting pre environment to ignore SSL certificates...");
  
  // Safely set Node.js environment variable if available (CLI only)
  try {
    if (typeof process !== 'undefined' && process.env) {
      process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
    }
  } catch (e) {
    // Ignore in UI environment
  }
  
  const axios = require('axios');
  const API_URL = bru.getEnvVar("API_URL");
  const TOKEN = bru.getEnvVar("TOKEN");

  // Configure axios to handle SSL and network issues
  const axiosConfig = {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${TOKEN}`
    },
    validateStatus: function (status) {
      return status < 500;
    },
    timeout: 30000
  };

  // Add tenant header if multitenant mode is enabled
  if (bru.getEnvVar("isMultitenant") == "true") {
    axiosConfig.headers['Tenant'] = `${bru.getEnvVar("tenant1")}`;
  }

  try {
    const vendorResponse = await axios.post(`${API_URL}/v2/vendors`, {
      "company": "Other Company",
      "namespacePrefixes": "uri://ed-fi.org",
      "contactName": "Other Application User",
      "contactEmailAddress": "otherapplication@example.com"
    }, axiosConfig);

    if (vendorResponse.status === 201) {
      console.log("âœ… Vendor created successfully");
      let headers = vendorResponse.headers; 
      expect(headers).to.have.property("location");
      const locationHeader = headers.location;
      if(locationHeader) {
          const locationStr = Array.isArray(locationHeader) ? locationHeader[0] : locationHeader;
          const id = locationStr.split("/").pop();
          if(id) {
              bru.setVar("OtherApplicationVendorId", id);
          }
      }
    } else {
      console.log("âŒ Failed to create vendor");
      console.log("Status:", vendorResponse.status);
      console.log("Response data:", JSON.stringify(vendorResponse.data, null, 2));
      throw new Error(`Failed to create vendor - Status: ${vendorResponse.status}, Data: ${JSON.stringify(vendorResponse.data)}`);
    }

    const applicationResponse = await axios.post(`${API_URL}/v2/applications`, {
        "applicationName": "Other Vendor Application",
        "vendorId": bru.getVar("OtherApplicationVendorId"),
        "claimSetName": "Ed-Fi Sandbox",
        "profileIds": [],
        "educationOrganizationIds": [ 255901 ],
        "odsInstanceIds": [bru.getVar("ODSInstanceId")],
        "enabled" : true
    }, axiosConfig);

    if (applicationResponse.status === 201) {
      console.log("âœ… Application created successfully");
      let headers = applicationResponse.headers; 
      expect(headers).to.have.property("location");
      const locationHeader = headers.location;
      if(locationHeader) {
          const locationStr = Array.isArray(locationHeader) ? locationHeader[0] : locationHeader;
          const appId = locationStr.split("/").pop();
          if(appId) {
              bru.setVar("OtherApplicationId", appId);
          }
      }
    } else {
      console.log("âŒ Failed to create application");
      console.log("Status:", applicationResponse.status);
      console.log("Response data:", JSON.stringify(applicationResponse.data, null, 2));
      throw new Error(`Failed to create application - Status: ${applicationResponse.status}, Data: ${JSON.stringify(applicationResponse.data)}`);
    }
    
  } catch (error) {
    console.log("Error in pre-request setup:", error.message);
  }

}

script:post-response {
  test("GET Application by Vendor: Status code is OK", function () {
      expect(res.getStatus()).to.equal(200);
  });
  
  const results = res.getBody();
  
  test("GET Application by Vendor: Response result includes applications", function () {
      expect(results.length).to.be.greaterThan(0);
  
      const indexOfApplication = results.map(
          function(application) { return application.id; }
      ).indexOf(bru.getVar("CreatedApplicationId"));
  
      const result = results[indexOfApplication];
      expect(result.applicationName).to.equal("Test Application");
      expect(result.claimSetName).to.equal("Ed-Fi Sandbox");
      expect(result.educationOrganizationIds.length).to.equal(1);
      expect(result.profileIds.length).to.equal(0);
      expect(result.odsInstanceIds.length).to.equal(1);
  });
  
  test("GET Application by Vendor: Response result is filtered by vendor", function () {
      const resultApplicationIds = results.map(
          function(application) { return application.id; }
      );
  
      expect(resultApplicationIds).to.contain(bru.getVar("CreatedApplicationId"));
      expect(resultApplicationIds).to.not.contain(bru.getVar("OtherApplicationId"));
  });
  
  test("GET Application by Vendor: Response results do not include key or secret", function () {
      results.forEach(function(result, i) {
          expect(result).to.not.have.property("key");
          expect(result).to.not.have.property("secret");
      });
  });
  
  const response = res.getBody();
  const Ajv = require('ajv');
  const ajv = new Ajv();
  const GetApplicationByVendor = {
    "type": "array",
    "items": [
      {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer"
          },
          "applicationName": {
            "type": "string"
          },
          "claimSetName": {
            "type": "string"
          },
          "educationOrganizationIds": {
            "type": "array",
            "items": {}
          },
          "vendorId": {
            "type": "integer"
          },
          "profileIds": {
            "type": "array",
            "items": {}
          },
          "odsInstanceIds": {
            "type": "array",
            "items": {}
          }
        },
        "required": [
          "id",
          "applicationName",
          "claimSetName",
          "educationOrganizationIds",
          "vendorId",
          "profileIds",
          "odsInstanceIds"
        ]
      }
    ]
  }

  test("GET Application by Vendor: Validation Schema Response", () => {
      const valid = ajv.validate(GetApplicationByVendor, response);
      expect(valid).to.be.true;
      
      if (!valid) {
          console.log("Schema validation errors:", ajv.errors);
      }
  });


}

settings {
  encodeUrl: true
}
